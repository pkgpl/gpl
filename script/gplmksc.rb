#!/usr/bin/ruby -w
# Program : Make SConstruct
# Date : 3 Mar 2011
require 'optparse'
require 'gpl/gplfortran'

# initialization
sconstruct='SConstruct'
envcheck={:gpl=>nil,:rsf=>nil,:mpi=>nil,:dmsc=>nil,:dmsz=>nil}
directory,sources=[],[]
env,cmd_target=nil,nil
incdir,libdir,libs=[],[],[]
run=nil

# parse options
opts=OptionParser.new
opts.banner="Usage: gplmksc [options] <f90 files>"
opts.on("-d","--mkdir Directory",String) {|val| directory << val}
opts.on("-e","--env Environment",String,'set environment: gpl/mpi/dmsc/dmsz/rsf/gplrsf') {|val| env=val}
opts.on("-l","--lib Library",	String,'add library') {|val| libs << val}
opts.on("-L","--libpath Path",	String,'add library path') {|val| libdir << val}
opts.on("-i","--include Path",	String,'add include path') {|val| incdir << val}
opts.on("-t","--target File",	String,'target file name') {|val| cmd_target="\"#{val}\","}
opts.on("-r","--run",	String,'run scons') {|val| run=true}
begin
	rest=opts.parse(ARGV)
rescue
	puts opts.to_s
	exit
end
rest.each{|file| sources << file }
if sources.empty? and directory.empty?
	puts opts.to_s
	exit
end

# inspect sources
incmod,incsub=[],[]
mpi,dms=nil,nil
gplmod=GplLibInfo.modules
gplsub=GplLibInfo.numeric
sources.each do |src|
	inspect=FortranInspect.new(src)
	# check module
	inspect.use.each {|mod| incmod << mod if gplmod.include? mod }
	# check subroutines
	inspect.call.each do |sub|
		if gplsub.include? sub and (not inspect.sub.include? sub)
			incsub << sub 
		end
	end
	mpi=true if inspect.call.include? 'mpi_init'
	dms=true if inspect.call.include? 'fdms_cxnumfact'
	#umf=true if inspect.call.include? 'ums21i' or inspect.call.include? 'umd21i' or inspect.call.include? 'umc21i' or inspect.call.include? 'umz21i'
end

# directory
cmd_mkdir=nil
if directory.size >0
	cmd_mkdir=<<END
dirs=#{directory.inspect}
for dir in dirs:
\tExecute(Mkdir(dir))\n
END
end

# environment
unless env
	envcheck.keys.each {|k| envcheck[k]=true if incmod.include? k.to_s }
	env='gpl' if envcheck[:gpl]
	env='rsf' if envcheck[:rsf]
	env='gplrsf' if envcheck[:gpl] and envcheck[:rsf]
	env='mpi' if mpi
	env='dmsc' if dms
end
if env
	env+='.'
else
	env=''
end

# include path, library path, library
unless (incmod.empty? or incmod==['rsf'])
	incdir << '|gplincdir|'
	libdir << '|gpllibdir|'
end
unless incsub.empty?
	puts "found #{incsub}"
	libdir << '|gpllibdir|'
	libs << 'numeric'
end
if incmod.include? 'rsf'
	incdir << '|rsfincdir|' 
	libdir << '|rsflibdir|'
	libs << 'rsff90'
	libs << 'rsf'
	libs << 'm'
end
incmod.each {|mod| libs << mod}

incdir.uniq!
libdir.uniq!
libs.uniq!

# command
cmd_compl=nil
cmd_libs  = (libs.empty?   ) ? '' : "LIBS=#{libs.inspect}"
cmd_incdir= (incdir.empty? ) ? '' : ",F90PATH=#{incdir.inspect.gsub('"|','').gsub('|"','')}"
cmd_libdir= (libdir.empty? ) ? '' : ",LIBPATH=#{libdir.inspect.gsub('"|','').gsub('|"','')}"

if sources.size >0
	cmd_compl=["#{env}Program(#{cmd_target}#{sources.inspect})\n"]
	unless cmd_libs.empty? and cmd_incdir.empty? and cmd_libdir.empty?
		cmd_compl << "#{env}Append(#{cmd_libs}#{cmd_incdir}#{cmd_libdir})\n"
		cmd_compl << "\n"
	else
		cmd_compl << "\n"
	end
end

HEADER=<<END
#SConstruct file generated by gpl mksc at #{Time.now}
from gpl.scons import *\n
END

if File.exists? sconstruct
	# replace old Program command
	fi=File.open(sconstruct,'r')
	lines=fi.readlines
	fi.close
	writeflag,dirflag=nil,nil

	File.open(sconstruct,'w') do |f|
		0.upto(lines.size-1) do |n|
			text=lines[n]
			if cmd_compl
				/.*Program.."([^,]*)"/=~text
				if $1==sources.first
					puts "replacing command for",$1
					writeflag=true
					if cmd_compl.size == 3
						text,lines[n+1],lines[n+2]=cmd_compl[0..2]
						#text+="\n" 
					else
						text,lines[n+1]=cmd_compl[0],"\n"
					end
					#if lines[n+1]
					#	lines[n+1]+="\n"
					#	lines[n+2]+="\n"
					#else
					#	text+="\n"
					#end
				end
			end
			if cmd_mkdir
				if /^dirs=/=~text
					eval text
					dirs+=directory
					text="dirs=#{dirs.uniq.inspect}\n"
					dirflag=true
				end
			end
			f.write(text)
		end
		f.write(cmd_compl.join) if cmd_compl unless writeflag
		f.write(cmd_mkdir.join) if cmd_mkdir unless dirflag
	end
else
	# new SConstruct
	File.open(sconstruct,'w') do |f|
		f.write(HEADER)
		f.write(cmd_mkdir.join) if cmd_mkdir
		f.write(cmd_compl.join) if cmd_compl
	end
end
if run
	if sources.size >0
		cmd_sys="scons -Q #{File.basename(sources.first,'.f90')}"
	else
		cmd_sys='scons -Q'
	end
	puts cmd_sys
	system(cmd_sys)
end
